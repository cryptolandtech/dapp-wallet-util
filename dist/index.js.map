{"version":3,"file":"index.js","sources":["../src/types.ts","../src/dapp.ts","../src/wallet-whitelist.ts","../src/utils.ts","../src/wallet.ts"],"sourcesContent":["export interface IWalletConfig {\n    name: string,\n    supportedBlockchains: Array<Blockchain>;\n    instanceKey: string\n}\n\nexport interface IAccount {\n    address: string;\n    networkId: string;\n}\n\nexport interface IBlockchainProvider {\n    autoRefreshOnNetworkChange: string;\n    selectedAccount: IAccount; \n\n    getAccounts();\n    addEventListener(eventName: string, callback);\n}\n\nexport interface IWallet {\n    blockchains: Map<Blockchain, IBlockchainProvider>;\n}\n\nexport enum MessageType {\n    WALLET_READY = 'walletReady',\n    WALLET_SCRIPT_INJECTED = 'scriptInjected',\n    WALLET_GRANT_PERMISSION_RESPONSE = 'grantPermissionResponse',\n    WALLET_GRANT_PERMISSION_REQUEST = 'grantPermissionRequest'\n}\n\nexport enum Blockchain {\n    zilliqa = 'zilliqa',\n    ethereum = 'ethereum'\n}","import { IWalletConfig, IWallet, MessageType, Blockchain } from \"./types\";\nimport { walletsWhitelist } from \"./wallet-whitelist\";\nimport { onMessage } from \"./utils\";\n\nconst BRIDGE_URL = 'https://cryptolandtech.github.io/dapp-wallet-util/';\n\nlet iframe: HTMLIFrameElement;\nlet iframeLoadInProgress: boolean = false;\nlet iframeLoadTimestamp: number = 0;\nlet iframePromise: Promise<HTMLIFrameElement>;\nlet walletList: Array<string> = [];\n\nonMessage(MessageType.WALLET_READY, (data) => {\n    if (data.walletId) {\n        walletList.push(data.walletId);\n    }\n});\n\nconst getIframe = (forceReLoad: boolean = false): Promise<HTMLIFrameElement> => {\n    if (iframeLoadInProgress) {\n        // iframe loading in progress\n        return iframePromise;\n    } else {\n        if (!iframe || forceReLoad) {\n            // iframe not loaded or requested force reload\n            iframeLoadInProgress = true;\n            iframePromise = new Promise((resolve) => {\n                const id = 'wallet-bridge-iframe-' + Math.random().toString().substr(2);\n                const i = document.createElement('iframe');\n                i.width = \"0\";\n                i.height = \"0\";\n                i.frameBorder = \"0\";\n                i.id = id;\n                i.src = BRIDGE_URL;\n    \n                // TODO implement timeout\n                i.onload = () => {\n                    iframeLoadTimestamp = Date.now();\n                    iframe = i;\n                    iframeLoadInProgress = false;\n                    resolve(i);\n                }\n                \n                walletList = [];\n                document.body.appendChild(i);\n            });\n            return iframePromise;\n        } else {\n            return Promise.resolve(iframe);\n        }\n    }\n}\n\nconst getWalletsList = (blockchain: Blockchain) => {\n    let wallets =  walletList\n        .map(id => walletsWhitelist[id])\n        .filter(Boolean)\n        \n    if (blockchain) {\n        wallets = wallets.filter(wallet => wallet.supportedBlockchains.includes(blockchain));\n    }\n\n    return wallets;\n}\n\nexport const getWallets = async (blockchain?: Blockchain, timeout: number = 3000): Promise<Array<IWalletConfig>> => {\n    await getIframe();\n\n    // if timeout already passes return wallets list\n    if (iframeLoadTimestamp + timeout <= Date.now()) {\n        return Promise.resolve(getWalletsList(blockchain));\n    }\n\n    // wait for timeout then return wallets list\n    return new Promise(resolve => {\n        setTimeout(() => {\n            resolve(getWalletsList(blockchain));\n        }, timeout);\n    });\n}\n\nconst getInjectedWalletInstance = (walletId: string) => {\n    let instance;\n    const wallet = walletsWhitelist[walletId];\n    if (wallet && (window as any)[wallet.instanceKey]) {\n        instance = (window as any)[walletsWhitelist[walletId].instanceKey];\n    }\n    return instance;\n}\n\nexport const getWalletInstance = async (walletId?: string): Promise<IWallet> => {\n    if (!walletId) {\n        // TODO: wallet id not set, search in local storage for a used wallet\n        throw new Error('This feature is not yet supported...');\n    }\n\n    if (walletId) {\n        const wallet = walletsWhitelist[walletId];\n        if (wallet) {\n            const walletInstance = getInjectedWalletInstance(walletId);\n            if (walletInstance) {\n                // wallet extension has already access to the page\n                return Promise.resolve(walletInstance);\n            } else {\n                // check that wallet is installed\n                await getWallets();\n                if (walletList.indexOf(walletId) >= 0) {\n                    // wallet extension doesn't have access to the page\n                    // trigger a grant access request\n                    return new Promise(async (resolve, reject) => {\n                        if (await requestPermission(walletId as string)) {\n                            resolve(getWalletInstanceAfterIsInjected(walletId as string));\n                        } else {\n                            reject('USER_DID_NOT_GRANT_PERMISSION');\n                        }\n                    });\n                } else {\n                    return Promise.reject('WALLET_NOT_INSTALLED');\n                }\n                \n            }\n        } else {\n            // wallet not recognized\n            // show a warning\n            console.warn(`Wallet with id: #{walletId} is not in whitelist. If you are a new wallet make a PR here: https://github.com/cryptolandtech/dapp-wallet-util`);\n            return Promise.reject('WALLET_ID_NOT_IN_WHITELIST');\n        }\n    } else {\n        return Promise.reject('WALLET_ID_NOT_PROVIDED');\n    }\n}\n\nconst requestPermission = (walletId: string): Promise<boolean> => {\n    return new Promise(async (resolve) => {\n        (await getIframe(true) as any).contentWindow.postMessage({type: MessageType.WALLET_GRANT_PERMISSION_REQUEST, walletId}, BRIDGE_URL);\n        let unsub = onMessage(MessageType.WALLET_GRANT_PERMISSION_RESPONSE, (data) => {\n            if (data.walletId && data.walletId === walletId) {\n                clearTimeout(timeout);\n                unsub();\n                resolve(!!data.response);\n            }\n        });\n\n        let timeout = setTimeout(() => {\n            unsub();\n            resolve(false);\n        }, 30000);\n    });\n}\n\nconst getWalletInstanceAfterIsInjected = (walletId: string): Promise<any> => {\n    const walletInstance = getInjectedWalletInstance(walletId);\n    if (walletInstance) {\n        // wallet extension has already access to the page\n        return Promise.resolve(walletInstance);\n    }\n\n    return new Promise((resolve, reject) => {\n        const unsub = onMessage(MessageType.WALLET_SCRIPT_INJECTED, (data) => {\n            if (data.walletId && data.walletId === walletId) {\n                unsub();\n                clearTimeout(timeout);\n                if ((window as any)[walletsWhitelist[walletId].instanceKey]) {\n                    return resolve((window as any)[walletsWhitelist[walletId].instanceKey]);\n                } else {\n                    reject('WALLET_INSTANCE_NOT_FOUND');\n                }\n            }\n        });\n\n        const timeout = setTimeout(() => {\n            unsub();\n            reject('WALLET_SCRIPT_INJECT_TIMEOUT');\n        }, 10000);\n    });\n}\n\n// trigger iframe preload\n// getIframe();","import { IWalletConfig, Blockchain } from \"./types\";\n\nexport const walletsWhitelist: {[id: string]: IWalletConfig} = {\n    moonlet: {\n        name: 'Moonlet Wallet',\n        supportedBlockchains: [Blockchain.zilliqa], \n        instanceKey: 'moonlet'\n    }\n}","export const onMessage = (type: string, callback: (data: any, ev?: MessageEvent) => any): () => any => {\n    const listener = (ev: MessageEvent) => {\n        if (ev.data.type === type && typeof callback === 'function') {\n            return callback(ev.data, ev);\n        }\n    };\n\n    window.addEventListener('message', listener);\n    return () => {\n        window.removeEventListener('message', listener);\n    }\n}","import { MessageType } from \"./types\";\nimport { onMessage } from \"./utils\";\n\nexport const sendWalletReadyEvent = (walletId) => {\n    window.parent.postMessage({\n        type: MessageType.WALLET_READY,\n        walletId\n    }, '*');\n}\n\nexport const sendScriptInjectedEvent = (walletId, target?) => {\n    window.parent.postMessage({\n        type: MessageType.WALLET_SCRIPT_INJECTED,\n        walletId\n    }, target || document.location.href);\n}\n\nexport const onGrantPermissionRequest = (walletId: string, callback: (data: any, ev?:MessageEvent) => void): () => any => {\n    if (typeof callback !== 'function') {\n        throw new Error('Callback should be a function.');\n    }\n\n    return onMessage(MessageType.WALLET_GRANT_PERMISSION_REQUEST, (data, ev: MessageEvent) => {\n        if (data.walletId === walletId) {\n            callback(data, ev);\n        }\n    }); \n}\n\nexport const sendGrantPermissionResponse = (walletId: string, response: boolean, target?: string) => {\n    window.parent.postMessage({\n        type: MessageType.WALLET_GRANT_PERMISSION_RESPONSE,\n        walletId,\n        response\n    }, target || '*');\n}"],"names":["MessageType","Blockchain","iframe","iframePromise","walletsWhitelist","moonlet","name","supportedBlockchains","zilliqa","instanceKey","onMessage","type","callback","listener","ev","data","window","addEventListener","removeEventListener","BRIDGE_URL","iframeLoadInProgress","iframeLoadTimestamp","walletList","WALLET_READY","walletId","push","const","getIframe","forceReLoad","Promise","resolve","id","Math","random","toString","substr","i","document","createElement","width","height","frameBorder","src","onload","Date","now","body","appendChild","getWalletsList","blockchain","wallets","map","filter","Boolean","wallet","includes","getWallets","timeout","setTimeout","getInjectedWalletInstance","instance","parent","postMessage","target","WALLET_SCRIPT_INJECTED","location","href","Error","WALLET_GRANT_PERMISSION_REQUEST","response","WALLET_GRANT_PERMISSION_RESPONSE","walletInstance","indexOf","reject","contentWindow","unsub","clearTimeout","requestPermission","getWalletInstanceAfterIsInjected","console","warn"],"mappings":"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"}